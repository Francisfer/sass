<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />

    <link
      href="https://fonts.googleapis.com/css?family=Josefin+Sans:300,400,400i|Nunito:300,300i"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="css/style.css" />
    <link rel="shortcut icon" type="image/png" href="img/favicon.png" />

    <title>nexter &mdash; your home, your freedom</title>
  </head>
  <!-- Notice that the body is the actual container -->
  <body class="container">
    <div class="sidebar">Sidebar</div>

    <!-- //////////////////////////////////////////////////////////////////////////////////////////////// -->

    <header class="header">Header</header>

    <!-- //////////////////////////////////////////////////////////////////////////////////////////////// -->

    <div class="realtors">Top 3 realtors</div>

    <!-- //////////////////////////////////////////////////////////////////////////////////////////////// -->

    <section class="features">
      <!-- .feature{feature $}*6 -->
      <!-- Notice that this feature block/component is completely independent from the feature class, meaning that, in theory, it would be reusable in another page. -->
      <!-- However, we place it in the same file (features) because they are closely related and, like this we avoid having to jump around different files  -->
      <!-- However it would be better to use the 8-1, but doing it like this while we don't get experience is not a bad idea -->
      <div class="feature">
        <svg class="feature__icon">
          <use xlink:href="../img/sprite.svg#icon-global"
        </svg>

        <!-- Notice that the h4 is not being built as an element of the feature block. It is a component because we are going to use this style across the page. Typography-->
        <h4 class="heading-4 heading-4--dark">World's best luxury homes</h4>

        <p class="feature__text">
          Lorem, ipsum dolor sit amet consectetur adipisicing elit. Tenetur
          distinctio necessitatibus pariatur voluptatibus.
        </p>
      </div>

      <div class="feature">
        <svg class="feature__icon">
          <use xlink:href="../img/sprite.svg#icon-trophy"
        </svg>

        <h4 class="heading-4 heading-4--dark">Only the best properties</h4>

        <p class="feature__text">
          Voluptatum mollitia quae. Vero ipsum sapiente molestias accusamus
          rerum sed a eligendi aut quia.
        </p>
      </div>

      <div class="feature">
        <svg class="feature__icon">
          <use xlink:href="../img/sprite.svg#icon-map-pin"
        </svg>

        <h4 class="heading-4 heading-4--dark">All homes in top locations</h4>

        <p class="feature__text">
          Tenetur distinctio necessitatibus pariatur voluptatibus quidem
          consequatur harum.
        </p>
      </div>

      <div class="feature">
        <svg class="feature__icon">
          <use xlink:href="../img/sprite.svg#icon-key"
        </svg>

        <!-- Notice that the h4 is not being built as an element of the feature block. It is a component because we are going to use this style across the page. -->
        <h4 class="heading-4 heading-4--dark">New home in one week</h4>

        <p class="feature__text">
          Vero ipsum sapiente molestias accusamus rerum. Lorem, ipsum dolor sit
          amet consectetur adipisicing elit.
        </p>
      </div>

      <div class="feature">
        <svg class="feature__icon">
          <use xlink:href="../img/sprite.svg#icon-presentation"
        </svg>

        <!-- Notice that the h4 is not being built as an element of the feature block. It is a component because we are going to use this style across the page. -->
        <h4 class="heading-4 heading-4--dark">Top 1% realtors</h4>

        <p class="feature__text">
          Quidem consequatur harum, voluptatum mollitia quae. Tenetur distinctio
          necessitatibus pariatur voluptatibus.
        </p>
      </div>

      <div class="feature">
        <svg class="feature__icon">
          <use xlink:href="../img/sprite.svg#icon-lock"
        </svg>

        <h4 class="heading-4 heading-4--dark">Secure payments on nexter</h4>

        <p class="feature__text">
          Pariatur voluptatibus quidem consequatur harum, voluptatum mollitia
          quae.
        </p>
      </div>
    </section>

    <!-- //////////////////////////////////////////////////////////////////////////////////////////////// -->

    <!-- The story (testimonial) is divided in two parts: the photo gallery and the content. In order for these to be different grid items, each of the sides have to be a different element.
    
    They belong to the same block (story), but they are different elements. It is not bad practice to have the block and the element without a parent block. By the code we know that they are both part of the story but we want them to be different grid items.
    -->

    <div class="story__pictures">Story pictures</div>

    <div class="story__content">Story content</div>

    <!-- //////////////////////////////////////////////////////////////////////////////////////////////// -->

    <section class="homes">Homes</section>

    <!-- //////////////////////////////////////////////////////////////////////////////////////////////// -->

    <section class="gallery">Gallery</section>

    <!-- //////////////////////////////////////////////////////////////////////////////////////////////// -->

    <footer class="footer">Footer</footer>
  </body>
</html>

<!-- 

1. This time the architecture has one component per part/section of the page layout. There are 8 parts in the layout that are going to be the grid items.
Must check if this is the best practice, because it will be much more easier this way.

///////////////////////////////////////////////

2. After having the markup, giving a background color to each one is very helpful.

///////////////////////////////////////////////

3. Now it's time to style the container. This is where the magic happens, we set display to grid and then start by specifying the rows.

    ROWS
    3.1 - The first row is where the header is going to be, so we want it to have 80% of the viewport height, so 80vh. This means that it is already responsive from the start.

    3.2 - The second row is for the features, it is clear that we have a grid in here too. We want this row to have the necessary height to fit the content. 
    If we add more content the row will grow with it and, also, this means that if we decrease the width, the content will adapt vertically (just like a media query, adds a row and removes a column).
    For this we want the min-content (auto is the default and it is the same as min content).

    3.3 - As for the third row (story - where we have two elements), it is not a function of the viewport height but the viewport width.
    VERY IMPORTANT - Saying that the row is not a function of the viewport height means that if we decrease the viewport width, the size of the boxes also decreases, adapting to the viewport width. 
    The header for ex only responds to the viewport height. We set this one to be 40% of the viewport width.

    3.4 - The forth, fifth and last rows are similar to the features row. We easily see that we have a grids in there as well and so we want the rows height to adapt to the content. min-content

    COLUMNS
    3.1 - It is very common in web design to use a design grid with 8, 12 or 16 predefined columns. 
    This is also what we are going to do here, although it may not really be necessary for this design.
    grid-template-columns: repeat(8, 1fr);

    3.2 - This produces 8 equally sized columns, with the first row to occupy 80% of the viewport height.
    This is actually not what we want because these columns constantly adapt their width to the viewport. 
    Have in mind that these eight columns represent the center of the website and we are making the desktop version, where we usually use something between 1100px and 1200 px (remember trillo with a max-width of 120rem).
    It still is quite small, but remember that we are going to add more stuff.
    This time we use 1140px, so divided by 8 is 142px that we round to 14rem.
    However, now they don't respond in width at all, because, of course this is a fixed width, which means that we have to use the minmax function.
    We really need to think here, we want these columns to have a width that is between the minimum content and the maximum of 14 rem, not the other way around.
    We want them to be 14rem but they can be smaller, but not smaller then the minimum content. This would be easier to see if we had content, but keep in mind this reasoning (we want them to be x size but they can either be wider or smaller)

    grid-template-columns: repeat(8, minmax(min-content, 14rem));

    3.3 - Now we add the sidebar, which is also a column with 8rem.
    grid-template-columns: 8rem repeat(8, minmax(min-content, 14rem));

    3.4 - NOTE - At this point we have the sidebar column with a fixed width and the eight columns with a minmax width.
    We need two things, to center the 8 columns between the end of the viewport and the sidebar (remember that the content is not centered in the viewport) and to fill the entire viewport (remember that these 8 columns and the sidebar have a "fixed width").
    The solution for this is to add two more columns, each occupying a fraction of the available space.

    grid-template-columns: 8rem 1fr repeat(8, minmax(min-content, 14rem) 1fr);

    Now we have our sidebar, the stretcher, the 8 columns and the final stretcher.

    Note that, if we didn't have the sidebar, we could just use the margin 0 auto trick to center all of this in the body or use the justify content property.

    Another reason why we want to do it like this is because we have full bleed sections like the story or the header. 

    These sections do not only occupy the 8 sections in the middle, they occupy the other two columns

  ///////////////////////////////////////////////

Now, in order to make our lives easier, let's name the column tracks. Naming the columns is always more important, in most cases we don't even want to size the rows, we just want them to assume the size of the content.

Pay attention on how things are done:
    - The sidebar-end is also the full-bleed start; the full bleed end is the last line.

    - The center start are the 8 columns with the center end at the end and we create a set of named lines for each one of them.
    8 col-starts and 8 col-end

grid-template-columns:
    [sidebar-start] 8rem [sidebar-end full-start] 1fr [center-start] repeat(
      8,
      [col-start] minmax(min-content, 14rem) [col-end]
    )
    [center-end]
    1fr [full-end];

As for the positioning, only the full bleed section are a bit tricky. 

The header and the realtors occupy the same line, the realtors have the last two of the height columns and the stretcher; and the header has the rest.

HEADER - it could be the col-start 7, but since this is what it marks the end of the header we use the end.

grid-column: full-start / col-end 6;

REALTORS
grid-column: col-start 7 / full-end;
Now we use the start because it is where the realtors start

1. Notice that we didn't specify the columns.

2. This lesson ends with the fact that, when we approach the size of the 8 columns, the stretchers almost disappear. 
This is exactly what we've told them to do because those columns occupy 1fr of the available space, if there is no space, they collapse.
But we don't want that behavior, we usually want some margin between the content and the margin of the page for when we shrink.
For this we use the minmax function again in order to maintain a minimum of 6rem (60px)
REMEMBER that this is done thinking in the center sections (the ones that are aligned to those eight columns) 

///////////////////////////////////////////////

Now we start to build the sections. 
FEATURES.

1. How and why to create grids inside of grids.
REMEMBER the possibility of using subgrid instead of creating them manually.
grid-template-columns: subgrid;

About the rows, we could define them with auto auto, but this is what is going to happen anyway when out items are placed inside the implicit grid.

After setting the grid to 3 cols and the gap, we fill the content. We have an svg that comes from an icon sprite that is already in the img folder, the heading (h4) and the paragraph. 
For the headings we use a different font-family than for the normal text.

2. After styling the content it's time to place it in the layout. For this of course we use again a grid. So .feature will, at this point become a grid container and not just a grid item.
One column for the svg, we already know its size but it is always better to set to auto or min-content, if we later change something it is already set to be the minimum size to fit the content.
Once again we don't define the rows. The content defines the rows.
There is something important when not defining the rows, when we try to span an element across a row, the -1 does not work, because we did not define the row itself, so that number does not make much sense. This shorthand only works for explicit grids.
grid-row: 1 / -1;
Instead we do 

3. Remember the trick when we where setting the icons to expand across the rows so that the height of the second column was defined by the h4 in the first row. lesson 109 min 10.
It makes sense because the paragraph is below the icon in the second row, we could move it to where we want but, since the icon is still in the first row only, the height of that entire row is defined by it. 
If we set the icon to occupy all the rows, the text is moved and the height of the first line is now defined by the h4.

4. Seems common for the row gap to be less than the column gap in these components.
row-gap: 1.5rem;
column-gap: 2.5rem;
After doing so, you notice that the space between the h4 and the paragraph is much bigger in the components that have less text.
This happens because the parent grid, the .features grid, which contains these 6 items makes it so the items fill the entire cells. It is the same as saying that the align-items is set to stretch by default.
So, in order for the space to be even, we set it to start.
align-items: start;

6. Now, if we decrease the width of the page, we see that we need to make it responsive in order to, at some point, collapse a column and add a row.
REVIEW auto-fit and auto-fill.
For this we need to define some new column tracks with auto-fit (it simply creates as many tracks as can fit based on the width that we define, collapsing the ones that are empty). 
Collapsing means extra space, so it is perfect for using the minmax function.
grid-template-columns: repeat(auto-fit, minmax(25rem, 1fr)); 25 rem is established by experimentation.


5. To move the icon a bit to the top, we just need to use translate in y.
transform: translate(-1rem, 5rem); in both y and x



////////////////////////////////////////////////////////

THINGS TO TAKE

1. He does not use any type of architecture, only one file for each section/part of the page. Although it would be better to use the 7-1 pattern, keep in mind that it is not so confusing to do it like this in the beginning.
Only after one section is made we can move the code to where it belongs.

2. Placeholder, extend vs mixins. IMPORTANT - to review.
With the extend, it is like the heading is copied into the %heading selector (this is why we call it placeholder, imagine the .heading-1 replacing the %heading).

%heading {
  font-family: $font-display;
  font-weight: 400;
}

.heading-1 {
  @extend %heading;
}

This is actually what happens, look how the css code stays:
.heading-4, .heading-3, .heading-2, .heading-1 {
  font-family: "Josefin Sans", sans-serif;
  font-weight: 400;
}

With mixins it works the other way around, the code would be pasted into each of these selectors.

3. Where and how to use min-content, max-content, auto-fit, auto-fill, minmax function.
 -->
